# å•é“¾è¡¨é—®é¢˜æ€»ç»“
è¿™ä¸¤å¤©æ¯”è¾ƒé—²ï¼Œå› æ­¤åˆ·äº†å‡ é“HackerRankä¸Šçš„é¢˜ç›®ã€‚[HackerRank](https://www.hackerrank.com)æ˜¯ä¸€ä¸ªç±»LeetCodeçš„ç½‘ç«™ï¼Œä¸è¿‡ä¸Šé¢çš„é¢˜ç›®æ›´åŠ åŸºç¡€å’Œç®€å•ï¼Œæ›´åŠ é€‚åˆæˆ‘è¿™ç§ç®—æ³•å’Œæ•°æ®ç»“æ„é›¶åŸºç¡€çš„äººï¼Œå› æ­¤åšèµ·æ¥ä¹Ÿæ›´æœ‰æˆå°±æ„Ÿå’Œä¿¡å¿ƒğŸ˜
å¥½äº†ï¼Œä¸‹é¢å°±å°†å•é“¾è¡¨çš„ä¸€äº›é¢˜ç›®æ€»ç»“ä¸€ä¸‹ã€‚é¦–å…ˆç»™å‡ºè¿™äº›é¢˜ç›®ä¸­é€šç”¨çš„å•é“¾è¡¨èŠ‚ç‚¹å®šä¹‰ï¼š
    
    struct Node {
        int data;
        struct Node *next;
    }
    
ç¬¬ä¸€é¢˜ï¼šé¡ºåºæ‰“å°å•é“¾è¡¨ä¸­çš„å…ƒç´ ã€‚
æ€è·¯ï¼šä»å¤´èŠ‚ç‚¹å¤„å¼€å§‹éå†è¾“å‡ºï¼Œç›´è‡³NULLã€‚
ä»£ç ï¼š

    void Print(Node *head)
    {
        if (head == NULL) {
            return;
        } 
        Node *ptr = head;
        while(ptr != NULL) {
            cout << ptr->data << endl;
            ptr = ptr->next;
        }
    }

ç¬¬äºŒé¢˜ï¼šç»™å®šä¸€ä¸ªæ•°å€¼ï¼Œç”Ÿæˆä¸€ä¸ªæ–°æ•°å€¼å¹¶æ’å…¥åˆ°å•é“¾è¡¨çš„å°¾éƒ¨ã€‚
æ€è·¯ï¼šéå†åˆ°å°¾èŠ‚ç‚¹ï¼Œç„¶ååˆ›å»ºä¸€ä¸ªæ–°çš„èŠ‚ç‚¹ï¼Œè®©å°¾èŠ‚ç‚¹çš„nextæŒ‡é’ˆæŒ‡å‘è¿™ä¸ªæ–°çš„èŠ‚ç‚¹ã€‚
ä»£ç ï¼š

    Node* Insert(Node *head,int data)
    {
        Node *newCell = (Node *)malloc(sizeof(Node));
        newCell->data = data;
        newCell->next = NULL;
        if (head == NULL) {
            return newCell;
        } else {
            Node *tail = head;
            while(tail->next != NULL) {
                tail = tail->next;
            }
            tail->next = newCell;
            return head;
        }
    }
    
ç¬¬ä¸‰é¢˜ï¼šç»™å®šä¸€ä¸ªæ•°å€¼ï¼Œç”Ÿæˆä¸€ä¸ªæ–°èŠ‚ç‚¹æ’å…¥åˆ°å•é“¾è¡¨çš„å¤´éƒ¨ã€‚
æ€è·¯ï¼šåˆ›å»ºä¸€ä¸ªæ–°çš„èŠ‚ç‚¹ï¼Œè®©è¿™ä¸ªæ–°èŠ‚ç‚¹çš„nextæŒ‡é’ˆæŒ‡å‘åŸæ¥é“¾è¡¨çš„å¤´éƒ¨ã€‚
ä»£ç ï¼š

    Node* Insert(Node *head,int data)
    {
        Node *newCell = (Node *)malloc(sizeof(Node));
        newCell->data = data;
        if (head == NULL) {
            newCell->next = NULL;
            return newCell;
        } else {
            newCell->next = head;
            return newCell;
        }
    }

ç¬¬å››é¢˜ï¼šç»™å®šä¸€ä¸ªä½ç½®å’Œæ•°å€¼ï¼Œç”Ÿæˆä¸€ä¸ªæ–°èŠ‚ç‚¹å¹¶æ’å…¥åˆ°å•é“¾è¡¨çš„ç›¸åº”ä½ç½®å¤„ã€‚
æ€è·¯ï¼šä¿æŒä¸€ä¸ªè®¡æ•°å™¨ï¼Œç„¶åå¼€å§‹éå†å•é“¾è¡¨ï¼ŒåŒæ—¶è®¡æ•°å™¨è¿›è¡Œæ›´æ–°ï¼Œå½“è®¡æ•°å™¨çš„å€¼ä¸ä½ç½®ç›¸ç­‰æ—¶ï¼Œè¡¨ç¤ºæ‰¾åˆ°äº†è¦æ’å…¥çš„ä½ç½®äº†ï¼Œä¹‹åçš„åšæ³•ç±»ä¼¼äºç¬¬ä¸‰é¢˜ã€‚
ä»£ç ï¼š
    
    Node* InsertNth(Node *head, int data, int position)
    { 
        Node *newCell = (Node *)malloc(sizeof(Node));
        newCell->data = data;
        if (head == NULL) {
            newCell->next = NULL;
            return newCell;
        } else {
            if (position == 0) {
                newCell->next = head;
                return newCell;
            } else {
                int i = 1;
                Node *ptr = head;
                while(ptr != NULL && i != position) {
                    i++;
                    ptr = ptr->next;
                }
                newCell->next = ptr->next;
                ptr->next = newCell;
                return head;
            }
        }
    }

ç¬¬äº”é¢˜ï¼šä»å•é“¾è¡¨ä¸­åˆ é™¤ä¸€ä¸ªç»™å®šä½ç½®å¤„çš„èŠ‚ç‚¹ã€‚
æ€è·¯ï¼šå¾ˆç®€å•ï¼Œä¸å¤šè¯´äº†ã€‚
ä»£ç ï¼š

    Node* Delete(Node *head, int position)
    {
        if (head == NULL) {
            return NULL;
        } else {
            Node *ptrToNode;
            if (position == 0) {
                ptrToNode = head->next;
                free(head);
                return ptrToNode;
            } else {
                int i = 1;
                ptrToNode = head;
                while(ptrToNode != NULL && i != position) {
                    i++;
                    ptrToNode = ptrToNode->next;
                }
                Node *temp = ptrToNode->next;
                ptrToNode->next = temp->next;
                free(temp);
                return head;
            }
        }
    }

ç¬¬å…­é¢˜ï¼šé€†åºæ‰“å°å•é“¾è¡¨ä¸­çš„å…ƒç´ ã€‚
æ€è·¯ï¼šä½¿ç”¨é€’å½’ã€‚
ä»£ç ï¼š

    void ReversePrint(Node *head)
    {
          if(head) {
            ReversePrint(head->next);
            cout << head->data << endl;
        } else {
            return;
        }
    }
    
ç¬¬ä¸ƒé¢˜ï¼šå°†ä¸€ä¸ªå•é“¾è¡¨ä¸­çš„æ‰€æœ‰å…ƒç´ é€†åºã€‚
æ€è·¯ï¼šé¦–å…ˆéœ€è¦ç¡®å®šè¿™ä¸ªå•é“¾è¡¨æ˜¯å¸¦æœ‰å¤´èŠ‚ç‚¹çš„è¿˜æ˜¯ä¸å¸¦æœ‰å¤´èŠ‚ç‚¹çš„ï¼Œå¸¦æœ‰å¤´èŠ‚ç‚¹çš„é“¾è¡¨åœ¨å¤„ç†èµ·æ¥ç¨å¾®å¤æ‚ä¸€ç‚¹ã€‚ç„¶åå¯ä»¥ç”¨ä¸‰ä¸ªæŒ‡é’ˆï¼Œåˆ†åˆ«æŒ‡å‘å½“å‰èŠ‚ç‚¹curï¼Œå‰ä¸€ä¸ªèŠ‚ç‚¹preï¼Œåä¸€ä¸ªèŠ‚ç‚¹nextï¼Œç„¶åè°ƒæ•´è¿™ä¸‰ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„æŒ‡å‘å…³ç³»ã€‚
ä»£ç ï¼š

    Node* Reverse(Node *head)
    {
        if (head == NULL) {
            return NULL;
        } else {
            Node *reverseHead = NULL;
            Node *cur = head;
            Node *pre = NULL;
            Node *next = NULL;
            while(cur != NULL) {
                next = cur->next;
                if (next == NULL) {
                    reverseHead = cur;
                }
                cur->next = pre;
                pre = cur;
                cur = next;
            }
            return reverseHead;
        }
    }

ç¬¬å…«é¢˜ï¼šæ¯”è¾ƒä¸¤ä¸ªå•é“¾è¡¨ä¸­çš„å…ƒç´ æ˜¯å¦ç›¸åŒ
æ€è·¯ï¼šç”¨ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«éå†ä¸¤ä¸ªé“¾è¡¨ï¼Œç„¶åæ¯”è¾ƒæŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹æ•°å€¼æ˜¯å¦ç›¸ç­‰ã€‚
ä»£ç ï¼š

    int CompareLists(Node *headA, Node* headB)
    {
        if(headA == NULL && headB == NULL) {
            return 0;
        } else if ((!headA && headB) || (headA && !headB)){
            return 0;
        } else {
                Node *ptrToA = headA, *ptrToB = headB;
                while(ptrToA && ptrToB && (ptrToA->data == ptrToB->data)) {
                    ptrToA = ptrToA->next;
                    ptrToB = ptrToB->next;
                }
                if(ptrToA == NULL && ptrToB == NULL) {
                    return 1;
                } else {
                    return 0;
                }
        }
    }

ç¬¬ä¹é¢˜ï¼šåˆå¹¶ä¸¤ä¸ªæœ‰åºå•é“¾è¡¨ï¼Œå°†åˆå¹¶çš„ç»“æœæ”¾åœ¨ä¸€ä¸ªæ–°é“¾è¡¨ä¸­ã€‚
æ€è·¯ï¼šç”¨ä¸¤ä¸ªæŒ‡é’ˆæ¥åˆ†åˆ«éå†ä¸¤ä¸ªé“¾è¡¨ï¼Œæ¯”è¾ƒè¿™ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹çš„æ•°å€¼å¤§å°ï¼Œ
è‹¥A<B,é‚£ä¹ˆA++,æ‹·è´Açš„æ•°æ®åˆ°C,ç›´åˆ°A>B;è‹¥A>B,åˆ™B++,æ‹·è´Bçš„æ•°æ®åˆ°C,ç›´åˆ°B>A;è‹¥A==B,åˆ™A++,B++,æ‹·è´Aæˆ–Båˆ°Cã€‚è‹¥å…¶ä¸­ä¸€æ¡é“¾è¡¨å…ˆéå†å®Œï¼Œåˆ™å°†å¦ä¸€æ¡é“¾è¡¨çš„æ•°æ®ç›´æ¥æ‹·è´åˆ°Cä¸­ã€‚
ä»£ç ï¼š

    Node* MergeLists(Node *headA, Node* headB)
    {
      if (headA == NULL && headB == NULL) {
            return NULL;
        } else if (! headA && headB) {
            return headB;
        } else if (headA && !headB) {
            return headA;
        } else {
            Node *ptrToA = headA, *ptrToB = headB;
            Node *cur = (Node *)malloc(sizeof(Node));
            Node *head = cur;
            while(ptrToA && ptrToB) {
                while(ptrToA && ptrToB && (ptrToA->data < ptrToB->data)) {
                    Node *newCell = (Node *)malloc(sizeof(Node));
                    newCell->data = ptrToA->data;
                    cur->next = newCell;
                    cur = newCell;
                    ptrToA = ptrToA->next;
                }
                while(ptrToA && ptrToB && (ptrToA->data > ptrToB->data)) {
                    Node *newCell = (Node *)malloc(sizeof(Node));
                    newCell->data = ptrToB->data;
                    cur->next = newCell;
                    cur = newCell;
                    ptrToB = ptrToB->next;
                }
                while(ptrToA && ptrToB && (ptrToA->data == ptrToB->data)) {
                    Node *newCell = (Node *)malloc(sizeof(Node));
                    newCell->data = ptrToA->data;
                    cur->next = newCell;
                    cur = newCell;
                    ptrToA = ptrToA->next;
                    ptrToB = ptrToB->next;
                }
            }
            if(!ptrToA && ptrToB) {
                while(ptrToB) {
                    Node *newCell = (Node *)malloc(sizeof(Node));
                    newCell->data = ptrToB->data;
                    cur->next = newCell;
                    cur = newCell;
                    ptrToB = ptrToB->next;
                }
                cur->next = NULL;
            } else if(ptrToA && !ptrToB) {
                while(ptrToA) {
                    Node *newCell = (Node *)malloc(sizeof(Node));
                    newCell->data = ptrToA->data;
                    cur->next = newCell;
                    cur = newCell;
                    ptrToA = ptrToA->next;
                }
                cur->next = NULL;
            } else if (!ptrToA && !ptrToB ) {
                cur->next = NULL;
            }
            return head->next;
        }
    }
    
ç¬¬åé¢˜ï¼šè·å¾—ç¦»ä¸€ä¸ªé“¾è¡¨å°¾éƒ¨è·ç¦»ä¸ºKçš„èŠ‚ç‚¹ã€‚
æ€è·¯ï¼šè®¾ç½®ä¸¤ä¸ªæŒ‡é’ˆï¼Œåˆå§‹åŒ–æ—¶å‡æŒ‡å‘å¤´èŠ‚ç‚¹ï¼Œç„¶åè®©ä¸€ä¸ªæŒ‡é’ˆå…ˆå¾€å‰ç§»åŠ¨Kä¸ªèŠ‚ç‚¹ï¼Œç„¶åè¿™ä¸¤ä¸ªæŒ‡é’ˆå†ä¸€èµ·å‘å‰ç§»åŠ¨ï¼Œå½“ç¬¬ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘é“¾è¡¨çš„å°¾éƒ¨æ—¶ï¼Œç¬¬äºŒä¸ªèŠ‚ç‚¹æ‰€æŒ‡çš„ä½ç½®æ­£å¥½å°±æ˜¯ç¦»å°¾éƒ¨è·ç¦»ä¸ºKçš„èŠ‚ç‚¹ã€‚
ä»£ç ï¼š
    
    int GetNode(Node *head,int positionFromTail)
    {
      // This is a "method-only" submission. 
      // You only need to complete this method. 
        Node *p, *cur;
        p = cur = head;
        for(int i = 0; i <= positionFromTail;i++) {
            if (p != NULL) {
                p = p->next;
            }
        }
        while(p) {
            cur = cur->next;
            p = p->next;
        }
        return cur->data;
    }
ç¬¬åä¸€é¢˜ï¼šåˆ é™¤ä¸€ä¸ªæœ‰åºå•é“¾è¡¨ä¸­çš„é‡å¤å…ƒç´ ã€‚
æ€è·¯ï¼šç”¨ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘å½“å‰èŠ‚ç‚¹curå’Œä¸‹ä¸€èŠ‚ç‚¹folï¼Œå½“folå’Œcurçš„æ•°å€¼ç›¸ç­‰æ—¶ï¼Œfol++ï¼Œç›´åˆ°ä¸å†ç›¸ç­‰ï¼Œè°ƒæ•´curå’Œfolï¼Œç„¶åcur++ã€‚
ä»£ç ï¼š

    Node* RemoveDuplicates(Node *head)
    {
        if(head == NULL) {
            return NULL;
        } else {
            Node *cur = head, *fol = cur->next;
            while(fol != NULL) {
                while(fol && (fol->data == cur->data)) {
                    fol = fol->next;
                }
                cur->next = fol;
                if(fol) {
                    cur = fol;
                    fol = cur->next;
                }
            }
            return head;
        }
    }

ç¬¬åäºŒé¢˜ï¼šæ£€æµ‹é“¾è¡¨ä¸­æ˜¯å¦æœ‰ç¯ã€‚
æ€è·¯ï¼šä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€ä¸ªæŒ‡é’ˆæ¯æ¬¡å¾€å‰ç§»åŠ¨ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä¸€ä¸ªæŒ‡é’ˆæ¯æ¬¡å¾€å‰ç§»åŠ¨ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œè‹¥æ˜¯é“¾è¡¨ä¸­æœ‰ç¯çš„è¯ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªæŒ‡é’ˆä¸€å®šä¼šç›¸é‡ï¼Œå› æ­¤å¯ä»¥ç”¨è¿™ä¸¤ä¸ªæŒ‡é’ˆæ˜¯å¦ä¼šç›¸ç­‰æ¥æ£€æµ‹é“¾è¡¨ä¸­æœ‰æ²¡æœ‰ç¯ã€‚
ä»£ç ï¼š
    
    bool has_cycle(Node* head) {
        if(head == NULL) {
            return false;
        } else {
            Node *p = head, *q = head;
            while(p && q && q->next) {
                q = q->next->next;
                p = p->next;
                if(p == q) {
                    return true;
                }
            }
            return false;
        }
    }

ç¬¬åä¸‰é¢˜ï¼šæ‰¾åˆ°ä¸¤ä¸ªé“¾è¡¨çš„åˆå¹¶ç‚¹ã€‚
æ€è·¯ï¼šé¦–å…ˆè®¡ç®—å‡ºè¿™ä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦å’Œé•¿åº¦å·®ï¼Œç„¶åè®¾ç½®ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘è¿™ä¸¤ä¸ªé“¾è¡¨çš„å¤´éƒ¨ï¼Œè®©é•¿çš„é‚£ä¸ªæŒ‡é’ˆå…ˆç§»åŠ¨é•¿åº¦å·®ä¸ªèŠ‚ç‚¹ï¼Œç„¶åä¸¤ä¸ªæŒ‡é’ˆå†ä¸€èµ·å‘å‰ç§»åŠ¨ï¼Œå½“è¿™ä¸¤ä¸ªæŒ‡é’ˆç›¸ç­‰çš„æ—¶å€™ï¼Œæ‰€æŒ‡çš„ç‚¹å°±æ˜¯è¿™ä¸¤ä¸ªé“¾è¡¨çš„åˆå¹¶ç‚¹ã€‚
ä»£ç ï¼š

    int FindMergeNode(Node *headA, Node *headB)
    {
        Node *ptrToA = headA,*ptrToB = headB;
        int lenA,lenB;
        lenA = lenB = 0;
        while(ptrToA) {
            lenA++;
            ptrToA = ptrToA->next;
        }
        while(ptrToB) {
            lenB++;
            ptrToB = ptrToB->next;
        }
        ptrToA = headA,ptrToB = headB;
        if(lenA < lenB) {
            Node *temp = ptrToB;
            ptrToB = ptrToA;
            ptrToA = temp;
            int x = lenA;
            lenA = lenB;
            lenB = x;
        }
        for(int i = 0; i < lenA-lenB;i++) {
            ptrToA = ptrToA->next;
        }
        while(ptrToA && ptrToA != ptrToB) {
            ptrToA = ptrToA->next;
            ptrToB = ptrToB->next;
        }
        return ptrToA->data;
    }
ç¬¬åå››é¢˜ï¼šå‘ä¸€ä¸ªæœ‰åºåŒå‘é“¾è¡¨ä¸­æ’å…¥ä¸€ä¸ªèŠ‚ç‚¹ã€‚
æ€è·¯ï¼šå’Œå‘å•é“¾è¡¨ä¸­æ’å…¥èŠ‚ç‚¹æ€è·¯ç›¸åŒï¼Œåªä¸è¿‡èŠ‚ç‚¹çš„å‰åå…³ç³»è®¾ç½®å¤šäº†å‡ æ­¥ã€‚
ä»£ç ï¼š
    
    Node* SortedInsert(Node *head,int data)
    {
        Node *newNode = (Node *)malloc(sizeof(Node));
        newNode->data = data;
        if(head == NULL) {
            newNode->next = NULL;
            newNode->prev = NULL;
            return newNode;
        } else {
            if(data < head->data) {
                newNode->next = head;
                head->prev = newNode;
                newNode->prev = NULL;
                return newNode;
            } else {
                Node *ptr = head,*cur;
                while(ptr && (data > ptr->data)) {
                    cur = ptr;
                    ptr = ptr->next;
                }
                if(! ptr) {
                    cur->next = newNode;
                    newNode->next = NULL;
                    newNode->prev = cur;
                    return head;
                } else {
                    cur->next = newNode;
                    newNode->next = ptr;
                    newNode->prev = cur;
                    ptr->prev = newNode;
                }
                return head;
            }
        }
    }
ç¬¬åäº”é¢˜ï¼šé€†åºä¸€ä¸ªåŒå‘é“¾è¡¨ã€‚
æ€è·¯ï¼šå’Œé€†åºä¸€ä¸ªå•é“¾è¡¨æ€è·¯ä¸€è‡´ï¼Œå¹¶ä¸”ç”±äºèŠ‚ç‚¹ä¸­æœ¬èº«å°±æœ‰prevå’Œnextä¿¡æ¯ï¼Œå› æ­¤åªéœ€è¦ç”¨ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘å½“å‰èŠ‚ç‚¹å³å¯ã€‚
ä»£ç ï¼š
    
    Node* Reverse(Node* head)
    {  
        if (head == NULL) {
            return NULL;
        } 
        Node *cur = head, *next = NULL,*reversedHead = NULL;
        while(cur) {
            next = cur->next;
            if (next == NULL) {
                reversedHead = cur;
            }
            cur->next = cur->prev;
            cur->prev = next;
            cur = next;
        }
        return reversedHead;
    }

