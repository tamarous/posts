##  找出出现奇数次的数字

### 题目描述
给定一个数组arr，其中只有一个数字出现了奇数次，其他数字都出现了偶数次，找出这个数字并打印它。
进阶版：有两个数字出现了奇数次，其他数字都出现了偶数次，找出这两个数字。
要求：时间复杂度为O(N)，空间复杂度为 O(1)

### 思路
使用异或运算符。整数 n 与 0 异或的结果是 n，整数 n 与整数 n 异或的结果是 0。在第一个问题里，只有一个数字出现了奇数次，那么我们可以声明一个变量 x，用它去和数组中的每个元素做异或运算，最后x中存的就是数组中只出现奇数次的数字。



```c++
class Solution {
public:
	int findOddTimesNum(vector<int> &nums) {
    	int x = 0;
    	for(int i = 0; i < nums.size() ;i ++) {
          	x ^= nums[i];
    	}
    	return x;
	}
};
```

对于进阶题来说，如果该数组中的 a 和 b 都出现了奇数次，那么用 x 来和数组中的每个元素异或的最终结果是 `x = a ^ b` ，这个数字不为 0，所以 x 肯定有一个 bit 位是不为 0 的，假设是第 k 位不为 0，那么 a 和 b 中肯定有一个的第 k 位是1，而另外一个的第 k 位是 0。接下来我们再声明一个变量 y，用它去和数组中第 k 位为 1 的那些元素来做异或运算，当遍历完成时 y 中存的就是 a 和 b 中的一个，而 x ^ y 就是另外一个。

```c++
class Solution {
public:
	vector<int> findOddTimesTwoNum(vector<int> &nums) {
    	vector<int> result;
    	int x = 0;
    	
    	for(int i = 0; i < nums.size(); i++) {
        	x ^= nums[i];
    	}
    	int y = x & (~x + 1);
    	for(int i = 0; i < nums.size(); i++) {
        	if (nums[i] & y != 0) {
            	y ^= nums[i];
        	}
    	}
    	x = x ^ y;
    	result.push_back(x);
    	result.push_back(y);
	}
};
```



 

