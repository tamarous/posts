#浅析虚函数表
翻译自国外一技术博客，原文地址在[这里](http://blog.httrack.com/blog/2014/05/09/a-basic-glance-at-the-virtual-table/)。

C++继承、虚函数和虚函数表是一些非常复杂奇怪的野兽，常常让大部分人望而却步。

将一个对象映射到另一个，或者调用一个虚函数可能是你在C++中会遇到的最常用的两个操作了，所以这么基础的操作却不能被每个人所理解是一件令人不齿的事情。

我已经用C编程很多年了，C的一个优点就是它没有什么奇怪的特性：当你定义一个结构体的时候，你可以在内存中看到它的布局，你可以察觉到指针被填充。其他的操作，比如将一个指针指向另一个对象（需要格外小心）不过是将内存地址从一种类型解释成另外一种类型，或者仅仅是移动一下地址。没有魔法。毫无惊喜。需要访问一个指针数组的第二个成员？这不过是基础的指针算术而已。

有些人在开始学习编程时直接学习了C++-在我看来是一件很糟糕的事情，他们会逐渐失去对内存中真实发生的事情的注意力的。

但是事情远比你想象的要简单。

##回顾基础

先看一个非常简单的对象。
    
    class A
    {
    private:
        int id;

    public:
        A():id(42)
        {
            printf("yay, my address is %p, and my id is %d\n", this, this->id );
        }
    };
    
这个类只有一个构造函数，也只有一个成员（一个整形数值）。这两个的本质是不同的：变量和函数是不同的类型。

为了简单，我们可以将这个类看作是一个C结构体，将类的方法看作是接受一个隐藏this指针的全局函数。类的成员可以通过this指针间接访问。

上述的代码可以用纯C写成如下形式：
    
    struct A 
    {
      int id;
    };

    void A_A(struct A* this) 
    {
      this->id = 42;
      printf("yay, my address is %p, and my id is %d!\n", this, this->id);
    }

这样的结果就是你需要手动调用构造器：
    
    Struct A a;
    A_A(&a);

而不是像这样：
    
    A a;
    
就是这样！C++用C实现的形式！所以尽管当使用类时，C++编译器会把一切都隐藏在幕后，但是被编译后的代码同上面的例子其实是类似的。


如果你在这个类中添加更多成员或者方法，原则是一样的：扩充结构体的结构，添加更多接受隐藏this指针为参数的全局函数。

>类A的实例占用的内存是多少？答案非常简单：这个类只有一个成员属性，它是一个整形变量，因此类A所占用的内存就是这个整形变量的所占用的内存，也就是4比特。

>如果类A中有一个普通的成员函数的话，它在内存中所占的空间是多少？这个答案也很简单：它的大小并不会改变，因为它仍然只含有一个成员变量（译者注：计算类的内存空间时，只需要计算成员属性和虚函数所占的空间）

##继承呢？看上去有些复杂

其实，一点也不复杂。

我们来看一个例子。例子中仍然是之前的类A，和类B、类C。B有一个名为"age"的属性，C有一个名为“mode”的成员属性，并且C继承自类A和类B。

    class A 
    {
    public:
      int id;

      A(): id(42) 
      {
        printf("A: yay, my address is %p, my size is %zu, and my id is %d!\n",
           this, sizeof(*this), this->id);
      }
    };

    class B 
    {
    public:
      int age;

      B(): age(7) 
      {
        printf("B: yay, my address is %p, my size is %zu, and my age is %d!\n",
           this, sizeof(*this), this->age);
      }
    };

    class C: public A, public B 
    {
    public:
      int mode;

      C(): mode(-1) 
      {
        printf("C: yay, my address is %p, my size is %zu, my id, age and mode     are %d, %d, %d!\n",
           this, sizeof(*this), this->id, this->age, this->mode);
      }
    };


C的实例c将会打印出如下的一些东西

    A: yay, my address is 0x73620f9f5c20, my size is 4, and my id is 42!
    B: yay, my address is 0x73620f9f5c24, my size is 4, and my age is 7!
    C: yay, my address is 0x73620f9f5c20, my size is 12, my id, age and mode are 42, 7, -1!
    
类C的构造器先调用它的父类的构造器，因此先打印出A和B的信息。这里，C++又一次将一切隐藏在幕后：对基类构造函数的调用是自动产生的。

你可以注意到：A和C所打印出的地址是相同的，而B打印出的地址是不同的，这是为什么呢？

让我们用纯C风格重新写以上代码

    struct A 
    {
      int id;
    };

    void A_A(struct A* this) 
    {
      this->id = 42;
      printf("A: yay, my address is %p, my size is %zu, and my id is %d!\n",
         this, sizeof(*this), this->id);
    }

    struct B 
    {
      int age;
    };

    // class B constructor
    void B_B(struct B *this) 
    {
      this->age = 7;
      printf("B: yay, my address is %p, my size is %zu, and my age is %d!\n",
         this, sizeof(*this), this->age);
    }

    struct C 
    {
      struct A a;
      struct B b;
      int mode;
    };

    void C_C(struct C *this) 
    {
      
      A_A(&this->a);
      B_B(&this->b);
      
      this->mode = -1;
      printf("C: yay, my address is %p, my size is %zu, my id, age and mode are %d, %d, %d!\n",
         this, sizeof(*this), this->a.id, this->b.age, this->mode);
    }
    
结构体C的结构是显而易见的：第一个成员就是原来类A的成员--这就是它们打印出的地址相同的原因，第二个是B的成员，而最后一个成员才是原来类C的成员。

在C++和C风格的代码中：

1. C所占用的内存空间是12比特
2. A处于C所占空间的开始部分
3. B处于A所占空间的相邻区域。
4. C特有的成员属性占据接下来的区域。

映射将产生相同的行为：

* static_cast<A*>(&c) == &(&c)->a == 0x73620f9f5c20
* static_cast<B*>(&c)) == &(&c)->b == 0x73620f9f5c24
* static_cast<C*>(&c)) == &c == 0x73620f9f5c20

##好吧，但是虚函数呢？用纯C风格可以表示它们吗？

让我们考虑一个简单的例子：向我们的前一个例子中添加一个虚函数print()，它的作用是打印出对象的类名和参数信息。我们的假设是，即使我们将类C的实例转换为A*或者B\*，我们也应该看见相同的输出。

    class A 
    {
    public:
        int id;

        A(): id(42) 
        {
            printf("A: yay, my address is %p, my size is %zu, and my id is %d!\n",this, sizeof(*this), this->id);
        }

        virtual void print() {
            printf("I am A(%d)\n", id);
        }
    };

    class B 
    {
    public:
      int age;

      B(): age(7) 
      {
          printf("B: yay, my address is %p, my size is %zu, and my age is %d!\n",
         this, sizeof(*this), this->age);
        }

        virtual void print() {
            printf("I am B(%d)\n", age);
        }
    };

    class C: public A, public B 
    {    
    public:
      int mode;

      C(): mode(-1) 
      {
            printf("C: yay, my address is %p, my size is %zu, my id, age and mode are %d, %d, %d!\n",
         this, sizeof(*this), this->id, this->age, this->mode);
       }

    virtual void print() {
        printf("I am C(%d, %d, %d)\n", id, age, mode);
        }
    };
    
如果我们创建了类C的一个实例c，那么以下四种调用方式会产生完全一样的结果。
    
    *. c.print();
    *. static_cast<A*>(&c)->print();
    *. static_cast<B*>(&c)->print();
    *. static_cast<C*>(&c)->print();

奥妙在哪里呢？让我们先看一下创建这个实例时的输出：
    
    A: yay, my address is 0x726fa25b7c00, my size is 16, and my id is 42!
    B: yay, my address is 0x726fa25b7c10, my size is 16, and my age is 7!
    C: yay, my address is 0x726fa25b7c00, my size is 32, my id, age and mode are 42, 7, -1!
    
可以看到，A和B不再是4个比特，而是16比特。C则变成了32个比特！不知怎么的，C++编译器确实在背后为我们的代码添加了一些东西！

现在来看下每个类实例中的实际内容。通过分析构造器中的指针，我们来找出来什么东西被加进了我们的代码中。

    static void print_object(const char *name, void *this_, size_t size) 
    {
      void **ugly = reinterpret_cast<void**>(this_);
      size_t i;
      printf("created %s at address %p of size %zu\n", name, this_, size);
      for(i = 0 ; i < size / sizeof(void*) ; i++) 
      {
        printf("  pointer[%zu] == %p\n", i, ugly[i]);
      }
    }
注：%zu用来输出size_t类型的变量;

记得要在每个构造器中添加如下代码：
    
    print_object(__FUNCTION__,this,sizeof(*this));

记住，当创建C的实例时，构造器是按照下面的规则被调用的：

    *. 基类A的构造器被调用(this指向C占据空间的开头)
    *. 基类B的构造器被调用(this指向从C占据空间开头处算起的第16比特的位置)
    *. 子类C的构造器被调用(this指向C占据空间的开头)
 
 下面是结果：
 
     created A at address 0x7082f962ccb0 of size 16
      pointer[0] == 0x400f20
      pointer[1] == 0x2a
    created B at address 0x7082f962ccc0 of size 16
      pointer[0] == 0x400f00
      pointer[1] == 0x7
    created C at address 0x7082f962ccb0 of size 32
      pointer[0] == 0x400ed0
      pointer[1] == 0x2a
      pointer[2] == 0x400ee8
      pointer[3] == 0xffffffff00000007   
 
可以看到：

    *. A包含了一个未知的额外指针(0x400f20)，并且id变量(0x2a == 42)被填充到8比特
    *. B包含了另一个未知的指针(0x400f00)，并且age变量(0x7)被填充到8比特
    *. C嵌入了A和B，自身还有mode变量（值为-1）:这些内容在内存中表现为0x2a，和0xffffffff00000007（age变量是00000007,mode变量是ffffffff）和两个额外的指针
    
看起来，结构大小变化的原因是一个隐藏的指针成员（在64位计算机中占8比特）被加入了类的实例中---如果你在处理数组时想要以8位对齐，那么编译器可能会将结构扩展到16位。也就是说，如果你有一个含有两个元素的数组，那么第二个元素将被填充到8比特，强迫它的大小是8比特的倍数。虽然有4个比特的空间被浪费了，但是这对保证8位对齐很有帮助。

等等！在C构造器中打印出的两个指针是不一样的！是的，我们发现：A类中的额外指针值是0x400f20,而它在C的构造器中的值变成了0x400ed0；B类中的额外指针值为0x400f00，而它在C构造器中则成了0x400ee8。

最后一点需要注意的：C只占据了32比特的空间！

    *. C中竟然没有隐藏指针！
    *. 编译器很明显对B的mode变量进行了填充！
    
所以，由于我们定义了虚函数，所以两个额外的指针被加入进来了。这意味着什么呢？

让我们回到最基础的部分：你怎么解释纯C中的类继承呢？

你可能会这样做：
    
    struct A 
    {
      int id;
    };

    // class A constructor
    void A_A(struct A *this) 
    {
      this->id = 42;
      print_object(__FUNCTION__, this,         sizeof(*this));
    }

    void A_print(struct A *this) {
      printf("I am A(%d)\n", this->id);
    }

    struct B
    {
      int age;
    };

    // class B constructor
    void B_B(struct B *this) 
    {
      this->age = 7;
      print_object(__FUNCTION__, this, sizeof(*this));
    }

    void B_print(struct B *this)
    {
      printf("I am B(%d)\n", this->age);
    }

    struct C 
    {
      struct A a;
      struct B b;
      int mode;
    };

    void C_C(struct C *this) 
    {
      // manually call base classes constructors first
      A_A(&this->a);
      B_B(&this->b);
      // then, user code
      this->mode = -1;
      print_object(__FUNCTION__, this, sizeof(*this));
    }

    void C_print(struct C *this) 
    {
      printf("I am C(%d, %d, %d)\n", this->a.id, this->b.age, this->mode);
    }
    
看起来和我们之前的代码类似。但是如何实现虚函数呢？我们得确保即使是只有一个A*或者B\*指针，我们也要调用正确的函数。

在类中为每一个虚函数添加一个函数指针并且在构造器中进行初始化是一种不错的解决方案。

就像这样：

    struct A 
    {
      void (*print)(struct A *this);
      int id;
    };

    // class A constructor
    void A_A(struct A *this) 
    {
      this->print = A_print;
      this->id = 42;
      print_object(__FUNCTION__, this,     sizeof(*this));
    }
    
    void A_print(struct A *this)
    {
        printf("I am A(%d)\n",this->id);
    }

    struct B 
    {
      void (*print)(struct B *this);
      int age;
    };

    // class B constructor
    void B_B(struct B *this) 
    {
      this->print = B_print;
      this->age = 7;
      print_object(__FUNCTION__, this, sizeof(*this));
    }

    void B_print(struct B *this) 
    {
      printf("I am B(%d)\n", this->age);
    }

    struct C 
    {
      struct A a;
      struct B b;
      void (*print)(struct C *this);
      int mode;
    };

    void C_C(struct C *this) 
    {
      // manually call base classes constructors first
      A_A(&this->a);
      B_B(&this->b);
      // then, user code
      this->print = C_print;
      this->a.print = C_print;  // we patch our own A->print function !!
      this->b.print = C_print;  // and we need to do it for B->print too!!
      this->mode = -1;
      print_object(__FUNCTION__, this, sizeof(*this));
    }

    void C_print(struct C *this) 
    {
      printf("I am C(%d, %d, %d)\n", this->a.id, this->b.age, this->mode);
    }

我们做了下面几件事：
    
    *. A和B的构造器初始化了它们各自的print()方法
    *. 在A和B的构造器之后，C的构造器初始化了自己版本的print()，并且重载了它。
    
现在，不管你有什么样的指针，下面这三行都有一样的行为：
    
    a->print(a);
    b->print(b);
    c->print(c);
    
但是，类C其实不需要一个额外的指针，因为我们在a.print()和b.print()中已经有了正确的版本。将它移除，并且写成下面这样：
    
    a->print(a)
    b->print(b)
    c->a.print(c)
    
然而，当将C类实例转换为A*或者B\*时，可能会出现一些小问题。当你调用a->print(a)时，指针a的类形是A\*。因此声明this->a.print = c_print 将会产生一个警告。类似的，当你调用b->print(b)时，this指针的类型将会是B\*。它的类型不仅会改变，而且还会有一个不同的地址，因为c->b位于C占据内存空间开头的第16比特处。

我们需要正确的类型转换！

    *. 将A*转换为C*是安全的：它们的地址一样，类型也可以安全地转换
    *. 将B*转换为C*需要改变地址，来找到C空间的开头位置
    
 因此我们可以写出如下代码：
 
    void C_print(struct C *this) 
    {
        printf("I am C(%d, %d, %d)\n", this->a.id, this->b.age, this->mode);
    }

    void CA_print(struct A *this) 
    {
        C_print((struct C*) this);
    }

    void CB_print(struct B *this) 
    {
      // we know that this points after the struct A layout
      // so let's fix the pointer by ourselves!
      size_t offset = (size_t) &((struct C*) NULL)->b;
      C_print((struct C*) ( ( (char*) this ) - offset ) );
    }

    void C_C(struct C *this) 
    {
      // manually call base classes constructors first
      A_A(&this->a);
      B_B(&this->b);
      // then, override functions
      this->a.print = CA_print;  // we patch our own function !!
      this->b.print = CB_print;  // and we need to do it for B too!!
      // this->print = C_print;  // useless
      // then, user code
      this->mode = -1;
      print_object(__FUNCTION__, this, sizeof(*this));
    } 
    
    
当完成了后，那么就会变成这样：
    
    *. c.a.print(&c.a) ==> I am C(42, 7, -1)
    *. c.b.print(&c.b) ==> I am C(42,7,-1)
    *. c.print(&c) ==> I am C(42,7,-1)
    
非常完美，不是吗？

不，还没有：如果我们向我们的类中加入更多的虚函数呢？这将会增加对象的大小，也需要在构造器中加入更多的指针初始化！每次都在分配同样的指针，无疑是对空间和时间的浪费！我们可不可以在一个静态的，全局的结构中为每个类准备一套指针，在构造器中仅仅初始化一个指向这些静态数据的指针呢？

下面是改进的版本——将这个含有特定函数指针的表称为vtbl,也就是虚函数表

    // type for global virtual function table structure A
    // this structure enumerates all virtual functions of A
    struct A;
    struct table_A 
    {
      void (*print)(struct A *this);
    };

    struct A 
    {
      const struct table_A *vtbl;
      int id;
    };

    void A_print(struct A *this) 
    {
      printf("I am A(%d)\n", this->id);
    }

    // the global, static table data for A
    // this structure enumerates all virtual functions of B
    static const struct table_A table_A_for_A = { A_print };

    void A_A(struct A *this) 
    {
      this->vtbl = &table_A_for_A;
      this->id = 42;
      print_object(__FUNCTION__, this, sizeof(*this));
    }

    // type for global virtual function table structure B
    struct B;
    struct table_B 
    {
      void (*print)(struct B *this);
    };

    struct B 
    {
      const struct table_B *vtbl;
      int age;
    };

    void B_print(struct B *this) 
    {
      printf("I am B(%d)\n", this->age);
    }

    // the global, static table data for B
    static const struct table_B table_B_for_B = { B_print };

    void B_B(struct B *this) 
    {
      this->vtbl = &table_B_for_B;
      this->age = 7;
      print_object(__FUNCTION__, this, sizeof(*this));
    }

    struct C 
    {
      struct A a;
      struct B b;
      int mode;
    };

    void C_print(struct C *this) 
    {
      printf("I am C(%d, %d, %d)\n", this->a.id, this->b.age, this->mode);
    }

    void CA_print(struct A *this) 
    {
      C_print((struct C*) this);
    }

    void CB_print(struct B *this) 
    {
      // we know that this points after the struct A layout
      // so let's fix the pointer by ourselves!
      size_t offset = (size_t) &((struct C*) NULL)->b;
      C_print((struct C*) ( ( (char*) this ) - offset ) );
    }

    // the global, static tables data for A and B structures, for C
    static const struct table_A table_A_for_C = { CA_print };
    static const struct table_B table_B_for_C = { CB_print };

    void C_C(struct C *this) 
    {
      // manually call base classes constructors first
      A_A(&this->a);
      B_B(&this->b);
      // Override virtual function pointers that have just been initialized by
      // A and B constructors with our own version. This allows to override all
      // possible virtual functions in base classes!
      this->a.vtbl = &table_A_for_C;
      this->b.vtbl = &table_B_for_C;
      this->mode = -1;
      print_object(__FUNCTION__, this, sizeof(*this));
    }

好了，我来告诉你一个秘密：这就是C++编译器在实现虚函数时所采用的方法！虚函数表被称为*虚表*，是编译后代码中的静态结构。在每个类构造器的基类初始化调用和用户代码间，都插入了额外的代码，来为不同的类类型设置相应的虚表指针。

值得注意的一些点：
    
    *. if you call a virtual function inside a base class constructor, you will not call the top-level function version, because the virtual table pointer has not yet been initialized (it will be initialized after the end of the base class constructor)
    （注：上述句子译者没有看懂，希望明白的朋友指教一下）
    
    *. 一个类只需要一个虚函数表
    
    *. 你可以为这些虚表结构添加更多信息，这将很有用！
       1. 类型名
       2. 可以获知类型的函数，比如实现一个隐藏的getClassType()虚函数
       3. 支持动态类型转换
       
       实际上，现在大部分编译器都在这么做！[Runtime Type Information](https://en.wikipedia.org/wiki/Run-time_type_information)信息实际上在一个虚表创建时就被包含了。
       
       现在你知道了当你定义一个虚函数时实际上会发生什么事了：并不是直接调用一个函数，而是间接地通过虚表来调用。
       
    *. 性能会受到一点点影响，因为你需要去一个静态表中读取函数指针。
    *. a potentially huge impact on performances because you can not inline anymore function calls
        (注：这句也没有看懂...)
        

   
       
     
       