# 视图编程指南 － 笔记

视图和窗口是用来展示程序的用户界面并处理用户与之的交互的。
一个应用程序往往只有一个窗口实例，却有很多视图和视图控制器。

##视图

###视图结构基础
视觉上的大部分操作是通过视图对象来完成的。

每个视图都有一个layer，通常是一个CALayer类的实例，来管理视图的状态并处理视图的动画。

实际的视图绘制代码很少被直接调用，然而如果被调用了，绘制结果就会被Core Animation缓存起来以供以后使用。使用缓存的内容可以减少更新视图的开销。

###视图继承关系与子视图管理
当一个视图A中包含了另一个视图B，A就成了B的父视图(superview)，B是A的子视图(subview)。

一个视图可能有多个子视图。如果两个子视图有重叠的部分，那么最后添加的视图显示在最上面。

更改父视图的一些属性会影响它的所有子视图的属性。

子视图的排列会影响程序对事件的处理过程。比如说系统向一个视图发送了一个touch事件。如果该视图不能处理的话，touch事件就会被发送到该视图的父视图，如果仍然不能处理，则沿着响应链继续向上传递。某些视图可能会将touch事件传递给视图控制器来处理。然而如果到了应用程序这里还是无法处理此事件，那么一般直接将此事件丢弃。

###视图绘制圈

UIView使用了一种使用时才请求的绘制模型。当一个视图第一次出现在屏幕上时，系统要求它绘制它的内容。系统捕捉这个视图的一个快照，并将这个快照作为视图的视觉表示。

如果视图的内容不变，那么绘制视图的代码就不会被调用。快照将在大部分使用该视图的操作中被重用。如果改变了视图的内容，你需要通知系统你对视图做了更改，系统将会重新要求视图进行绘制并保存重绘后的视图的快照。

当视图的内容改变时，你需要调用视图的**setNeedsDisplay**或者**setNeedsDisplayInRect:**方法。这些方法告诉系统视图的状态改变了，需要在下一次刷新时进行重绘。

通常是采用**drawRect:**方法来绘制自定义视图的内容。

###内容模式
**content mode**用来控制当视图的几何发生改变时，是否回收它的内容以及如何重复利用这些内容。

当发生如下事情时，需要考虑视图的content mode:

* 改变视图的**frame**或**bounds**的长或宽。
* 将一个变换赋值给视图的**transform**属性。

对大部分视图来说，默认的**contentMode**属性是UIViewContentModeScaleToFill。

你可以将视图的contentMode设置为**UIViewContentModeRedraw**来强制要求视图在每次几何信息发生改变时都进行重绘，但是一般来说都需要避免使用这个值。


###内置的动画支持

UIView的许多属性都可以动画化，你需要做的仅仅是：
1. 告诉UIKit你想要执行一个动画。
2. 改变属性的值。

下面列出了UIView类可以添加动画的属性：
1. frame:视图的位置及大小的改变
2. bounds:视图的大小的改变
3. center:视图的位置的改变
4. transform:对视图进行旋转或放大缩小。
5. alpha:改变视图的透明度
6. backgroundColor:改变视图的背景色
7. contentStretch:改变视图的内容如何伸展。

###Frame，Bounds以及Center的关系

* frame确定了在其父视图的坐标系统中，该视图的大小和位置。
* bounds确定了在其自己的坐标系统中，该视图的大小。
* center确定了在其父视图的坐标系统中，该视图的中心点坐标。

当改变这些属性中的某个时，可能会对另外几个属性产生影响。

* 当设置frame属性时，bounds属性会根据frame的大小进行调整，center属性也会改变到新的中心位置。
* 当设置center时，frame的原点值也会相应改变。
* 当设置bounds的大小时，frame的大小也会相应改变。

默认情况下，一个视图的frame不会被剪裁到它的父视图的frame。因此，任何位于父视图frame之外的视图都会被完全渲染出来。可以设置父视图的**clipsToBounds=YES**来改变此行为。


###坐标系统间的转换
仿射变换，是一个指定了一个坐标系中的点如何映射到另一个坐标系中的矩阵。通过仿射变换，你可以改变某个视图相对于它的父视图的大小、位置和朝向。

* 当需要改变整个视图的内容时，只需要改变该视图的transform属性。
* 如果需要改变视图的某个部分的内容，那么需要重写该视图的drawRect:方法，在此方法中对相关的图形上下文进行修改。

调用CGContextGetCTM可以获得与某个图形上下文相关的仿射变换。
CTM即current transformation matrix。

###运行时的交互模型

当屏幕上发生触摸事件时，所经历的过程如下：

1. 用户触摸屏幕。
2. 硬件向UIKit框架报告触摸事件的发生。
3. UIKit框架将触摸事件包装为一个UIEvent类型的对象，将它分发到合适的对象处。 
4. 在你的代码中进行事件处理。
* 改变视图或者其子视图的属性。
* 调用setNeedsLayout来指示视图或者其子视图需要对layout进行更新。
* 调用setNeedsDisplay或者setNeedsDisplayInRect:来指示视图或者其子视图需要进行重绘。
* 向一个controller报告属性数据的改变。
5. 如果一个视图的尺寸改变了，UIKit根据下面的规则来更新子视图:
* 如果已经为视图配置了自动尺寸适应的规则，那么UIKit会依据这些规则来调整子视图的大小和位置。
* 如果视图重载了**layoutSubviews**方法，UIKit就会调用这个这个方法。
6. 如果任意视图的任意部分被标记为需要重绘，那么UIKit就会要求视图重新绘制它自己。
7. 更新的视图和程序的其它可见内容组合在一起，然后被送入显卡中。
8. 显卡将这些内容呈现在屏幕上。

###使用视图的一些小技巧

* 视图不一定总是有对应的视图控制器。
* 将自定义的绘制代码减至最少。
* 在声明视图时尽可能使它不透明，即将opague属性赋值为YES。
* 当屏幕滚动时，调整视图的绘制行为。例如，在滚动开始时，你可以暂时降低被渲染内容的质量，或者改变content mode。
* 不要向UIControl对象或者其子类添加子视图。

##窗口

###窗口起到的作用
* 包含了程序的可见内容。
* 向视图及程序的其它对象分发触摸事件。
* 和视图控制器一起工作，以加快设备朝向的改变。

###和窗口有关的操作
* 使用窗口来完成坐标变换。
* 使用窗口通知来跟踪和窗口有关的改变。

###创建和配置一个窗口
####在程序中创建一个窗口
在`application:didFinishLaunchingWithOptions:`方法中，通过下面的代码来创建窗口:

    self.window = [[[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]] autorelease];

####设置窗口的根视图
    
    [self setWindow:[[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]];

      MainViewController *mainViewController = [[MainViewController alloc] initWithStyle:UITableViewStylePlain];
      UINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:mainViewController];
      [[self window] setRootViewController:navigationController];
    
      [[self window] makeKeyAndVisible];    

###监视窗口的改变
当窗口发生变化时，会发出如下的通知：

    `UIWindowDidBecomeVisibleNotification`
    `UIWindowDidBecomeHiddenNotification`
    `UIWindowDidBecomeKeyNotification`
    `UIWindowDidResignKeyNotification`